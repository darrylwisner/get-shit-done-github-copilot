# Upstream Sync + Release Mirror Workflow
# Detects changes in upstream gsd-build/get-shit-done, merges them,
# regenerates the Copilot wrapper layer, verifies it, and creates/updates a PR.
# Also polls upstream for new releases and auto-publishes a matching fork release.
#
# One-time prerequisites (run once before first execution):
#   gh label create upstream-sync --color 0075ca --description "Upstream sync PR" --repo <fork>
#   gh label create automated --color e4e669 --description "Automated workflow" --repo <fork>
#   gh label create upstream-mirror --color d93f0b --description "Upstream release mirror" --repo <fork>
#   Enable: Settings → General → Pull Requests → Allow auto-merge: ON
#   Verify: COPILOT_PAT secret has 'repo' scope (required for tag push to trigger release.yml)
#
# Schedule: runs every 4 hours. Both sync and release-mirror jobs exit silently when nothing to do.

on:
  schedule:
    - cron: '0 */4 * * *'  # Every 4 hours (00:00, 04:00, 08:00, 12:00, 16:00, 20:00 UTC)
  workflow_dispatch:
  push:
    branches:
      - 'copilot/**'

name: Upstream Sync

concurrency:
  group: upstream-sync
  cancel-in-progress: false

env:
  DEFAULT_BRANCH: main
  EXPECTED_REPO: darrylwisner/get-shit-done-github-copilot
  UPSTREAM_BRANCH: main
  UPSTREAM_REPO: gsd-build/get-shit-done

jobs:
  sync:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: write
      pull-requests: write
      issues: write

    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      # SAFETY: Always run this assertion first. Add --repo "$GITHUB_REPOSITORY" to any new gh command you add here.
      - name: Assert fork context
        run: |
          if [ "$GITHUB_REPOSITORY" != "${{ env.EXPECTED_REPO }}" ]; then
            echo "ERROR: This workflow is running on '$GITHUB_REPOSITORY' but is only intended to run on '${{ env.EXPECTED_REPO }}'."
            echo "Refusing to proceed — this prevents accidental writes to the wrong repository."
            exit 1
          fi

      - name: Checkout fork (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Configure git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add upstream remote and fetch
        run: |
          git remote add upstream "https://github.com/${{ env.UPSTREAM_REPO }}.git" || true
          git fetch upstream "${{ env.UPSTREAM_BRANCH }}"

      - name: Detect upstream changes
        id: detect
        run: |
          FORK_HEAD=$(git rev-parse HEAD)
          UPSTREAM_HEAD=$(git rev-parse "upstream/${{ env.UPSTREAM_BRANCH }}")
          SHORT_SHA=$(git rev-parse --short "upstream/${{ env.UPSTREAM_BRANCH }}")

          echo "fork_head=$FORK_HEAD" >> "$GITHUB_OUTPUT"
          echo "upstream_head=$UPSTREAM_HEAD" >> "$GITHUB_OUTPUT"
          echo "short_sha=$SHORT_SHA" >> "$GITHUB_OUTPUT"

          # Check if upstream has commits not in fork HEAD
          DIFF_COUNT=$(git rev-list HEAD..upstream/${{ env.UPSTREAM_BRANCH }} --count)
          if [ "$DIFF_COUNT" -eq 0 ]; then
            echo "no_changes=true" >> "$GITHUB_OUTPUT"
            echo "No upstream changes detected. Exiting."
          else
            echo "no_changes=false" >> "$GITHUB_OUTPUT"
            echo "Detected $DIFF_COUNT new upstream commit(s)."
          fi

      - name: Exit silently if no changes
        if: steps.detect.outputs.no_changes == 'true'
        run: exit 0

      - name: Create/reset working branch
        if: steps.detect.outputs.no_changes != 'true'
        run: |
          git checkout -B automated/upstream-sync origin/${{ env.DEFAULT_BRANCH }}

      - name: Merge upstream changes
        if: steps.detect.outputs.no_changes != 'true'
        id: merge
        run: |
          if ! git merge "upstream/${{ env.UPSTREAM_BRANCH }}" --no-edit; then
            CONFLICT_FILES=$(git diff --name-only --diff-filter=U | tr '\n' '\n- ' | sed 's/^/- /')
            cat > /tmp/issue-body.md << 'ISSUE_EOF'
          ## Upstream Sync Merge Conflict

          The automated upstream sync encountered a merge conflict and could not complete.

          **Upstream commit:** ${{ steps.detect.outputs.short_sha }}
          **Upstream HEAD:** ${{ steps.detect.outputs.upstream_head }}
          **Fork HEAD (before merge):** ${{ steps.detect.outputs.fork_head }}

          ### Conflicting files
          ISSUE_EOF
            git diff --name-only --diff-filter=U | sed 's/^/- /' >> /tmp/issue-body.md
            cat >> /tmp/issue-body.md << 'ISSUE_EOF'

          ### Resolution steps
          1. Check out the `automated/upstream-sync` branch locally
          2. Resolve conflicts manually
          3. Run `node scripts/generate-prompts.mjs && node scripts/verify-prompts.mjs`
          4. Push and open PR manually

          **Workflow run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          ISSUE_EOF
            gh issue create \
              --repo "$GITHUB_REPOSITORY" \
              --title "Upstream sync merge conflict (upstream@${{ steps.detect.outputs.short_sha }})" \
              --body-file /tmp/issue-body.md \
              --label "upstream-sync"
            exit 1
          fi

      - name: Run prompt generator
        if: steps.detect.outputs.no_changes != 'true'
        run: |
          node scripts/generate-prompts.mjs > /tmp/gen_output.txt 2>&1
          echo "Generator output:"
          cat /tmp/gen_output.txt

      - name: Run prompt verifier
        if: steps.detect.outputs.no_changes != 'true'
        id: verify
        run: |
          if ! node scripts/verify-prompts.mjs > /tmp/ver_output.txt 2>&1; then
            cat > /tmp/issue-body.md << 'ISSUE_EOF'
          ## Upstream Sync Verifier Failure

          The upstream sync completed merge and regeneration, but the verifier failed. No PR was created.

          **Upstream commit:** ${{ steps.detect.outputs.short_sha }}
          **Upstream HEAD:** ${{ steps.detect.outputs.upstream_head }}

          ### Generator output
          ```
          ISSUE_EOF
            cat /tmp/gen_output.txt >> /tmp/issue-body.md
            cat >> /tmp/issue-body.md << 'ISSUE_EOF'
          ```

          ### Verifier output
          ```
          ISSUE_EOF
            cat /tmp/ver_output.txt >> /tmp/issue-body.md
            cat >> /tmp/issue-body.md << 'ISSUE_EOF'
          ```

          ### Resolution steps
          1. Review the verifier errors above
          2. Fix `scripts/generate-prompts.mjs` or `scripts/verify-prompts.mjs` as needed (do NOT edit upstream content)
          3. Re-run workflow or fix and push manually

          **Workflow run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          ISSUE_EOF
            gh issue create \
              --repo "$GITHUB_REPOSITORY" \
              --title "Upstream sync verifier failed (upstream@${{ steps.detect.outputs.short_sha }})" \
              --body-file /tmp/issue-body.md \
              --label "upstream-sync"
            exit 1
          fi
          echo "Verifier passed."
          cat /tmp/ver_output.txt

      - name: Commit regenerated wrapper files
        if: steps.detect.outputs.no_changes != 'true'
        run: |
          git add .github/prompts/ .github/agents/ .github/instructions/ || true
          if ! git diff --cached --quiet; then
            git commit -m "chore: regenerate Copilot wrapper layer for upstream@${{ steps.detect.outputs.short_sha }}"
          else
            echo "No wrapper file changes to commit."
          fi

      # SYNC-03: Close any open PRs for automated/upstream-sync before force-pushing so the
      # replacement PR always reflects the current branch state cleanly.
      - name: Close superseded sync PRs
        if: steps.detect.outputs.no_changes != 'true'
        run: |
          OPEN_PRS=$(gh pr list \
            --repo "$GITHUB_REPOSITORY" \
            --head "automated/upstream-sync" \
            --state open \
            --json number \
            --jq '.[].number' 2>/dev/null || echo "")

          for PR_NUM in $OPEN_PRS; do
            gh pr comment "$PR_NUM" \
              --repo "$GITHUB_REPOSITORY" \
              --body "Closing — superseded by a new upstream sync run (upstream@${{ steps.detect.outputs.short_sha }}). A fresh PR will be created for this run."
            gh pr close "$PR_NUM" \
              --repo "$GITHUB_REPOSITORY"
            echo "Closed stale PR #${PR_NUM}."
          done

      - name: Force-push working branch
        if: steps.detect.outputs.no_changes != 'true'
        run: |
          git push --force-with-lease origin automated/upstream-sync

      - name: Build PR body
        if: steps.detect.outputs.no_changes != 'true'
        run: |
          RANGE="${{ steps.detect.outputs.fork_head }}...${{ steps.detect.outputs.upstream_head }}"
          CHANGED_FILES=$(git diff --name-only "${{ steps.detect.outputs.fork_head }}" "${{ steps.detect.outputs.upstream_head }}" -- commands/gsd/ get-shit-done/ agents/ 2>/dev/null | sed 's/^/- /' || echo "- (none detected)")

          cat > /tmp/pr-body.md << PR_EOF
          ## Upstream sync from \`gsd-build/get-shit-done\`

          **Upstream commit:** \`${{ steps.detect.outputs.short_sha }}\`
          **Commit range:** \`${RANGE}\`

          ### Changed upstream files
          ${CHANGED_FILES}

          ### Copilot wrapper layer
          ✅ Generator and verifier passed. Wrapper files regenerated automatically.

          ---
          *This PR was created automatically by the upstream-sync workflow.*
          *See [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.*
          PR_EOF

      # SYNC-01/02: Create (or update) the PR and immediately enable auto-merge so it lands on
      # main without manual intervention as soon as required checks pass.
      # Prerequisite: Settings → General → Pull Requests → "Allow auto-merge" must be ON.
      - name: Create or update PR
        if: steps.detect.outputs.no_changes != 'true'
        id: create_pr
        run: |
          SHORT_SHA="${{ steps.detect.outputs.short_sha }}"
          PR_TITLE="sync: upstream changes from ${SHORT_SHA}"

          # After the close-stale step, there should be no open PR, but guard defensively.
          EXISTING_PR=$(gh pr list \
            --repo "$GITHUB_REPOSITORY" \
            --head "automated/upstream-sync" \
            --state open \
            --json number \
            --jq '.[0].number' 2>/dev/null || echo "")

          if [ -z "$EXISTING_PR" ]; then
            PR_URL=$(gh pr create \
              --repo "$GITHUB_REPOSITORY" \
              --base "${{ env.DEFAULT_BRANCH }}" \
              --head "automated/upstream-sync" \
              --title "${PR_TITLE}" \
              --body-file /tmp/pr-body.md \
              --label "upstream-sync" \
              --label "automated")
            echo "Created new PR: ${PR_URL}"
            PR_NUMBER=$(basename "$PR_URL")
            echo "pr_number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"
          else
            gh pr edit "$EXISTING_PR" \
              --repo "$GITHUB_REPOSITORY" \
              --title "${PR_TITLE}" \
              --body-file /tmp/pr-body.md
            echo "Updated existing PR #${EXISTING_PR}."
            echo "pr_number=${EXISTING_PR}" >> "$GITHUB_OUTPUT"
          fi

      # SYNC-01/02: Enable auto-merge on the PR (merge commit strategy preserves upstream commit SHAs
      # in main's ancestry, which is required for GitHub's 'X commits behind upstream' indicator to
      # clear correctly after merge. Squash would create a new SHA and main would always appear behind.)
      # This is a no-op when auto-merge is already enabled; safe to run on every sync.
      - name: Enable auto-merge on sync PR
        if: steps.detect.outputs.no_changes != 'true' && steps.create_pr.outputs.pr_number != ''
        run: |
          gh pr merge "${{ steps.create_pr.outputs.pr_number }}" \
            --repo "$GITHUB_REPOSITORY" \
            --auto \
            --merge
          echo "Auto-merge enabled on PR #${{ steps.create_pr.outputs.pr_number }}."

  repair:
    name: Self-Repair (Copilot Agent)
    runs-on: ubuntu-latest
    needs: sync
    if: always() && needs.sync.result != 'skipped'
    timeout-minutes: 90
    permissions:
      contents: write
      pull-requests: write
      issues: write
    env:
      GH_TOKEN: ${{ secrets.COPILOT_PAT }}

    steps:
      # SAFETY: Always run this assertion first. Add --repo "$GITHUB_REPOSITORY" to any new gh command you add here.
      - name: Assert fork context
        run: |
          if [ "$GITHUB_REPOSITORY" != "${{ env.EXPECTED_REPO }}" ]; then
            echo "ERROR: This workflow is running on '$GITHUB_REPOSITORY' but is only intended to run on '${{ env.EXPECTED_REPO }}'."
            echo "Refusing to proceed — this prevents accidental writes to the wrong repository."
            exit 1
          fi

      - name: Check COPILOT_PAT
        id: preflight
        run: |
          if [ -z "${{ secrets.COPILOT_PAT }}" ]; then
            echo "::warning::COPILOT_PAT secret is not set. Skipping self-repair job."
            echo "skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout
        if: steps.preflight.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.COPILOT_PAT }}

      - name: Setup Node
        if: steps.preflight.outputs.skip != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Fetch upstream
        if: steps.preflight.outputs.skip != 'true'
        run: |
          git remote add upstream https://github.com/gsd-build/get-shit-done.git 2>/dev/null || true
          git fetch upstream

      - name: Repair loop
        if: steps.preflight.outputs.skip != 'true'
        id: repair_loop
        run: |
          set -euo pipefail

          MAX_ATTEMPTS=3
          ATTEMPT=0
          REPAIR_NEEDED=false
          REPAIR_SUCCEEDED=false
          REPO_OWNER="${GITHUB_REPOSITORY%%/*}"

          # Gather diagnostic context once
          UPSTREAM_DIFF=$(git diff HEAD upstream/main -- . ':(exclude)commands/gsd' ':(exclude)get-shit-done' ':(exclude)agents' 2>/dev/null | head -c 20000 || true)
          GENERATOR_SRC=$(cat scripts/generate-prompts.mjs)
          VERIFIER_SRC=$(cat scripts/verify-prompts.mjs)

          # Run initial verify to see if repair is needed
          if node scripts/verify-prompts.mjs > /tmp/verify_initial.log 2>&1; then
            echo "Verifier passed — no repair needed."
            echo "repair_needed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          REPAIR_NEEDED=true
          INITIAL_ERRORS=$(cat /tmp/verify_initial.log | head -c 5000)

          build_repair_prompt() {
            local attempt=$1
            local prior_patches=""
            if [ "$attempt" -ge 2 ] && [ -f /tmp/patch_attempt_1.diff ]; then
              prior_patches="\n\n## Failed Patch — Attempt 1\n\`\`\`diff\n$(cat /tmp/patch_attempt_1.diff | head -c 5000)\n\`\`\`"
            fi
            if [ "$attempt" -ge 3 ] && [ -f /tmp/patch_attempt_2.diff ]; then
              prior_patches="${prior_patches}\n\n## Failed Patch — Attempt 2\n\`\`\`diff\n$(cat /tmp/patch_attempt_2.diff | head -c 5000)\n\`\`\`"
            fi

            local framing=""
            if [ "$attempt" -eq 3 ]; then
              framing=" This is the last attempt before human escalation."
            fi

            cat <<PROMPT
          You are the GSD upstream-sync repair agent. Analyze the upstream diff and verifier errors below, then update \`scripts/generate-prompts.mjs\` and/or \`scripts/verify-prompts.mjs\` to make the verifier pass.${framing}

          RULES:
          - NEVER modify files under: commands/gsd/, get-shit-done/, agents/
          - Only edit scripts/ and .github/prompts/ if needed
          - After edits, run: node scripts/generate-prompts.mjs && node scripts/verify-prompts.mjs
          - Open a PR targeting branch: automated/upstream-sync

          ## Verifier Errors
          \`\`\`
          ${INITIAL_ERRORS}
          \`\`\`

          ## Upstream Diff (truncated to 20k chars)
          \`\`\`diff
          ${UPSTREAM_DIFF}
          \`\`\`

          ## scripts/generate-prompts.mjs (current)
          \`\`\`js
          ${GENERATOR_SRC}
          \`\`\`

          ## scripts/verify-prompts.mjs (current)
          \`\`\`js
          ${VERIFIER_SRC}
          \`\`\`
          ${prior_patches}
          PROMPT
          }

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "::group::Repair attempt $ATTEMPT of $MAX_ATTEMPTS"

            PROMPT_TEXT=$(build_repair_prompt "$ATTEMPT")
            printf '%s' "$PROMPT_TEXT" > /tmp/repair_prompt_${ATTEMPT}.txt

            # Invoke Copilot agent (use --body-file to avoid shell escaping issues with JS source)
            gh agent-task create \
              --repo "$GITHUB_REPOSITORY" \
              --base "automated/upstream-sync" \
              --follow \
              --body-file /tmp/repair_prompt_${ATTEMPT}.txt \
              || true

            # Capture what changed
            git diff HEAD > /tmp/patch_attempt_${ATTEMPT}.diff 2>/dev/null || true

            # Check verifier
            if node scripts/verify-prompts.mjs > /tmp/verify_attempt_${ATTEMPT}.log 2>&1; then
              echo "Verifier passed on attempt $ATTEMPT."
              REPAIR_SUCCEEDED=true
              echo "repair_succeeded=true" >> "$GITHUB_OUTPUT"
              echo "repair_needed=true" >> "$GITHUB_OUTPUT"
              echo "::endgroup::"
              break
            else
              echo "::warning::Verifier failed after attempt $ATTEMPT."
              INITIAL_ERRORS=$(cat /tmp/verify_attempt_${ATTEMPT}.log | head -c 5000)
            fi

            echo "::endgroup::"
          done

          # Write final outputs (repair_succeeded written in loop on success; write exhaustion flag here)
          if [ "$REPAIR_SUCCEEDED" = false ] && [ "$REPAIR_NEEDED" = true ]; then
            echo "repair_needed=true" >> "$GITHUB_OUTPUT"
            echo "repair_succeeded=false" >> "$GITHUB_OUTPUT"
            echo "attempts_exhausted=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Filesystem guard (post-repair)
        if: steps.preflight.outputs.skip != 'true' && steps.repair_loop.outputs.repair_needed == 'true'
        run: |
          bash scripts/guard-upstream-files.sh post-commit

      - name: Escalate — Create GitHub issue
        if: >
          steps.preflight.outputs.skip != 'true' &&
          steps.repair_loop.outputs.attempts_exhausted == 'true'
        env:
          GH_TOKEN: ${{ secrets.COPILOT_PAT }}
        run: |
          set -euo pipefail
          REPO_OWNER="${GITHUB_REPOSITORY%%/*}"

          # Deduplicate: skip if open sync-failed issue already exists
          EXISTING=$(gh issue list \
            --repo "$GITHUB_REPOSITORY" \
            --label "sync-failed" \
            --state open \
            --json number \
            --jq 'length' 2>/dev/null || echo "0")
          if [ "$EXISTING" -gt 0 ]; then
            echo "::warning::Open sync-failed issue already exists. Skipping duplicate creation."
            exit 0
          fi

          # Build diagnostic dump (respecting 65,536 char limit)
          UPSTREAM_DIFF=$(git diff HEAD upstream/main -- . \
            ':(exclude)commands/gsd' ':(exclude)get-shit-done' ':(exclude)agents' \
            2>/dev/null | head -c 15000 || true)

          PATCH_1=$([ -f /tmp/patch_attempt_1.diff ] && cat /tmp/patch_attempt_1.diff | head -c 8000 || echo "(none)")
          PATCH_2=$([ -f /tmp/patch_attempt_2.diff ] && cat /tmp/patch_attempt_2.diff | head -c 8000 || echo "(none)")
          PATCH_3=$([ -f /tmp/patch_attempt_3.diff ] && cat /tmp/patch_attempt_3.diff | head -c 8000 || echo "(none)")

          VERIFY_LOG=$(cat /tmp/verify_attempt_3.log 2>/dev/null | head -c 4000 || \
                       cat /tmp/verify_initial.log 2>/dev/null | head -c 4000 || echo "(none)")

          cat > /tmp/issue_body.md <<ISSUE
          Self-repair agent failed after 3 attempts on run [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}).

          @${REPO_OWNER} — manual intervention required.

          ## Summary
          The upstream sync detected changes that broke the compatibility layer (generate-prompts / verify-prompts). The Copilot repair agent was invoked 3 times with escalating context but could not produce a passing verifier run.

          ---

          ## Verifier Output (last attempt)
          \`\`\`
          ${VERIFY_LOG}
          \`\`\`

          ## Upstream Diff (truncated)
          \`\`\`diff
          ${UPSTREAM_DIFF}
          \`\`\`

          ## Patch — Attempt 1
          \`\`\`diff
          ${PATCH_1}
          \`\`\`

          ## Patch — Attempt 2
          \`\`\`diff
          ${PATCH_2}
          \`\`\`

          ## Patch — Attempt 3
          \`\`\`diff
          ${PATCH_3}
          \`\`\`
          ISSUE

          gh issue create \
            --repo "$GITHUB_REPOSITORY" \
            --title "sync-failed: Copilot repair exhausted after 3 attempts (run #${{ github.run_number }})" \
            --label "sync-failed" \
            --body-file /tmp/issue_body.md

  guard:
    # SAFETY: Always run the 'Assert fork context' step first. Add --repo "$GITHUB_REPOSITORY" to any new gh command you add here.
    name: Filesystem Guard (copilot/* branches)
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/heads/copilot/')
    timeout-minutes: 10
    permissions:
      contents: write

    steps:
      # SAFETY: Always run this assertion first. Add --repo "$GITHUB_REPOSITORY" to any new gh command you add here.
      - name: Assert fork context
        run: |
          if [ "$GITHUB_REPOSITORY" != "${{ env.EXPECTED_REPO }}" ]; then
            echo "ERROR: This workflow is running on '$GITHUB_REPOSITORY' but is only intended to run on '${{ env.EXPECTED_REPO }}'."
            echo "Refusing to proceed — this prevents accidental writes to the wrong repository."
            exit 1
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch upstream
        run: |
          git remote add upstream https://github.com/gsd-build/get-shit-done.git 2>/dev/null || true
          git fetch upstream

      - name: Run filesystem guard
        run: |
          bash scripts/guard-upstream-files.sh post-commit

  release-mirror:
    name: Release Mirror
    runs-on: ubuntu-latest
    needs: sync
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    timeout-minutes: 15
    permissions:
      contents: write
      issues: write
    env:
      GH_TOKEN: ${{ secrets.COPILOT_PAT }}

    steps:
      # SAFETY: Always run this assertion first. Add --repo "$GITHUB_REPOSITORY" to any new gh command you add here.
      - name: Assert fork context
        run: |
          if [ "$GITHUB_REPOSITORY" != "${{ env.EXPECTED_REPO }}" ]; then
            echo "ERROR: This workflow is running on '$GITHUB_REPOSITORY' but is only intended to run on '${{ env.EXPECTED_REPO }}'."
            echo "Refusing to proceed — this prevents accidental writes to the wrong repository."
            exit 1
          fi

      - name: Check COPILOT_PAT
        id: preflight
        run: |
          if [ -z "${{ secrets.COPILOT_PAT }}" ]; then
            echo "::warning::COPILOT_PAT secret is not set. Skipping release-mirror job."
            echo "skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Detect upstream release
        if: steps.preflight.outputs.skip != 'true'
        id: detect_release
        run: |
          UPSTREAM_REPO="${{ env.UPSTREAM_REPO }}"

          UPSTREAM_TAG=$(gh api "repos/${UPSTREAM_REPO}/releases/latest" \
            --jq '.tag_name' 2>/dev/null || echo "")

          if [ -z "$UPSTREAM_TAG" ] || [ "$UPSTREAM_TAG" = "null" ]; then
            echo "No upstream release found. Exiting silently."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "upstream_tag=${UPSTREAM_TAG}" >> "$GITHUB_OUTPUT"
          echo "skip=false" >> "$GITHUB_OUTPUT"
          echo "Upstream latest release: ${UPSTREAM_TAG}"

      - name: Check if already mirrored
        if: steps.preflight.outputs.skip != 'true' && steps.detect_release.outputs.skip != 'true'
        id: check_mirror
        run: |
          UPSTREAM_TAG="${{ steps.detect_release.outputs.upstream_tag }}"

          MIRRORED=$(gh release list \
            --repo "$GITHUB_REPOSITORY" \
            --limit 100 \
            --json tagName \
            --jq "[.[] | select(.tagName | contains(\"upstream-${UPSTREAM_TAG}\"))] | length" \
            2>/dev/null || echo "0")

          if [ "$MIRRORED" -gt 0 ]; then
            echo "Already mirrored upstream release ${UPSTREAM_TAG}. Exiting silently."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "skip=false" >> "$GITHUB_OUTPUT"
          echo "New upstream release detected: ${UPSTREAM_TAG}"

      # REL-06: Validate that the fork is no more than 1 release behind upstream.
      # Runs regardless of whether the current upstream tag is already mirrored.
      # A gap of 0 (fully current) or 1 (mirror job will handle it this run) is normal and silent.
      # A gap > 1 means the mirror job has been failing silently — alert the maintainer.
      - name: Lockstep validation
        if: steps.preflight.outputs.skip != 'true' && steps.detect_release.outputs.skip != 'true'
        run: |
          set -euo pipefail
          UPSTREAM_REPO="${{ env.UPSTREAM_REPO }}"
          REPO_OWNER="${GITHUB_REPOSITORY%%/*}"

          # Get the last 10 upstream release tag names (newest first)
          UPSTREAM_TAGS=$(gh api "repos/${UPSTREAM_REPO}/releases?per_page=10" \
            --jq '[.[].tag_name]' 2>/dev/null || echo "[]")

          # Get fork's latest release tag
          FORK_LATEST=$(gh api "repos/$GITHUB_REPOSITORY/releases/latest" \
            --jq '.tag_name // empty' 2>/dev/null || echo "")

          if [ -z "$FORK_LATEST" ] || [ "$FORK_LATEST" = "null" ]; then
            # No fork releases yet — gap = total upstream count in our window
            GAP=$(echo "$UPSTREAM_TAGS" | jq 'length')
          else
            # Extract the embedded upstream tag: "v0.0.3-upstream-v2.1.0" → "v2.1.0"
            EMBEDDED=$(echo "$FORK_LATEST" | sed 's/.*-upstream-//' || echo "")

            if [ -z "$EMBEDDED" ]; then
              # Fork latest release is not a mirror release — treat as unknown gap
              GAP=99
            else
              # Find position (0-indexed) of embedded tag in upstream releases list
              # Position 0 = fully current, 1 = one behind (this run will fix it), >1 = alert
              POSITION=$(echo "$UPSTREAM_TAGS" | jq --arg tag "$EMBEDDED" 'index($tag) // 99')
              GAP=$POSITION
            fi
          fi

          echo "Release lockstep gap: ${GAP} (fork is ${GAP} upstream release(s) behind)"

          if [ "$GAP" -le 1 ]; then
            echo "Gap is acceptable (≤1). No alert needed."
            exit 0
          fi

          # Gap > 1: create or update a deduplicating alert issue
          ISSUE_TITLE="[upstream-mirror] Release lockstep gap"
          UPSTREAM_LATEST="${{ steps.detect_release.outputs.upstream_tag }}"

          EXISTING=$(gh issue list \
            --repo "$GITHUB_REPOSITORY" \
            --search "is:issue is:open \"${ISSUE_TITLE}\" in:title" \
            --json number \
            --jq '.[0].number' 2>/dev/null || echo "")

          cat > /tmp/lockstep-body.md << BODY_EOF
          ## Release lockstep gap detected

          The fork is **${GAP}** upstream release(s) behind. The release-mirror job should keep this gap at ≤1 on each run. A persistent gap suggests the mirror job has been failing silently.

          | Field | Value |
          |---|---|
          | Upstream latest release | \`${UPSTREAM_LATEST}\` |
          | Fork latest release | \`${FORK_LATEST:-"(none)"}\` |
          | Gap | ${GAP} release(s) |
          | Workflow run | [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |

          ### Resolution
          1. Check the release-mirror job logs for the failing run.
          2. If the release-mirror job completed successfully this run, the gap will reduce to 0 automatically.
          3. Close this issue once the fork's latest release mirrors the upstream latest.
          BODY_EOF

          if [ -n "$EXISTING" ] && [ "$EXISTING" != "null" ]; then
            gh issue comment "$EXISTING" \
              --repo "$GITHUB_REPOSITORY" \
              --body-file /tmp/lockstep-body.md
            echo "::warning::Lockstep gap=${GAP}. Updated existing issue #${EXISTING}."
          else
            gh issue create \
              --repo "$GITHUB_REPOSITORY" \
              --title "${ISSUE_TITLE}" \
              --label "upstream-mirror" \
              --label "bug" \
              ${REPO_OWNER:+--assignee "$REPO_OWNER"} \
              --body-file /tmp/lockstep-body.md
            echo "::warning::Lockstep gap=${GAP}. Created new alert issue."
          fi

      # Gate step: consolidates all skip signals into a single `proceed` output.
      # A skipped step emits empty-string outputs; 'someStep.outputs.x != true' is TRUE for empty string,
      # which would cause all downstream write-steps to fire incorrectly if gated only on check_mirror.
      # Using == 'true' here means the gate itself being skipped (empty proceed) naturally blocks downstream.
      - name: Gate — proceed only if release is new
        if: steps.preflight.outputs.skip != 'true' && steps.detect_release.outputs.skip != 'true' && steps.check_mirror.outputs.skip != 'true'
        id: gate
        run: |
          echo "proceed=true" >> "$GITHUB_OUTPUT"
          echo "All guards passed — proceeding with tag push and release mirroring."

      - name: Compute fork tag
        if: steps.gate.outputs.proceed == 'true'
        id: compute_tag
        run: |
          UPSTREAM_TAG="${{ steps.detect_release.outputs.upstream_tag }}"

          FORK_LATEST=$(gh api "repos/$GITHUB_REPOSITORY/releases/latest" \
            --jq '.tag_name' 2>/dev/null || echo "")

          if [ -z "$FORK_LATEST" ] || [ "$FORK_LATEST" = "null" ]; then
            FORK_PATCH=0
          else
            BASE_VER="${FORK_LATEST%%-*}"     # "v0.0.3-upstream-v2.1.0" → "v0.0.3"
            FORK_PATCH="${BASE_VER##*.}"       # "v0.0.3" → "3"
          fi

          NEXT_PATCH=$((FORK_PATCH + 1))
          NEW_TAG="v0.0.${NEXT_PATCH}-upstream-${UPSTREAM_TAG}"

          echo "new_tag=${NEW_TAG}" >> "$GITHUB_OUTPUT"
          echo "Computed new fork tag: ${NEW_TAG}"

      - name: Checkout fork for tag push
        if: steps.gate.outputs.proceed == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.COPILOT_PAT }}

      - name: Configure git identity
        if: steps.gate.outputs.proceed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Push fork tag via COPILOT_PAT
        # COPILOT_PAT REQUIRED: GITHUB_TOKEN tag pushes do NOT trigger downstream workflows.
        # release.yml fires on push:tags:v* — this ONLY works if the tag is pushed via a PAT.
        if: steps.gate.outputs.proceed == 'true'
        id: push_tag
        run: |
          git remote set-url origin "https://x-access-token:${{ secrets.COPILOT_PAT }}@github.com/${{ github.repository }}.git"
          NEW_TAG="${{ steps.compute_tag.outputs.new_tag }}"
          UPSTREAM_TAG="${{ steps.detect_release.outputs.upstream_tag }}"

          git tag -a "$NEW_TAG" -m "Mirror upstream release ${UPSTREAM_TAG}"
          git push origin "$NEW_TAG"

          echo "Pushed tag: ${NEW_TAG}"

      - name: Poll for release.yml to create release
        if: steps.gate.outputs.proceed == 'true'
        id: poll_release
        run: |
          NEW_TAG="${{ steps.compute_tag.outputs.new_tag }}"
          CREATED=false

          echo "Polling for release creation by release.yml (max 5 min: 20 × 15s)..."
          for i in $(seq 1 20); do
            RELEASE_ID=$(gh api "repos/$GITHUB_REPOSITORY/releases/tags/${NEW_TAG}" \
              --jq '.id // empty' 2>/dev/null || echo "")
            if [ -n "$RELEASE_ID" ]; then
              echo "Release created (id=${RELEASE_ID}) after attempt ${i}."
              CREATED=true
              echo "created=true" >> "$GITHUB_OUTPUT"
              echo "release_id=${RELEASE_ID}" >> "$GITHUB_OUTPUT"
              break
            fi
            echo "  Waiting... attempt ${i}/20"
            sleep 15
          done

          if [ "$CREATED" = "false" ]; then
            echo "::warning::release.yml did not create release within 5 minutes. Will create directly."
            echo "created=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Build release body
        if: steps.gate.outputs.proceed == 'true'
        run: |
          NEW_TAG="${{ steps.compute_tag.outputs.new_tag }}"
          UPSTREAM_TAG="${{ steps.detect_release.outputs.upstream_tag }}"
          UPSTREAM_REPO="${{ env.UPSTREAM_REPO }}"

          UPSTREAM_BODY=$(gh api "repos/${UPSTREAM_REPO}/releases/latest" \
            --jq '.body' 2>/dev/null || echo "")

          # Guard: jq returns literal string "null" for JSON null fields (P2)
          if [ -z "$UPSTREAM_BODY" ] || [ "$UPSTREAM_BODY" = "null" ]; then
            UPSTREAM_BODY="_Upstream release notes unavailable._"
          fi

          # Quoted heredoc for static fork header — prevents expansion of any $ in fork-controlled text (P3)
          cat > /tmp/release-body.md << 'HEADER_EOF'
          ## Fork Mirror: __NEW_TAG__

          | Field | Value |
          |---|---|
          | Fork tag | `__NEW_TAG__` |
          | Upstream release | `__UPSTREAM_TAG__` |
          | Upstream release URL | __UPSTREAM_URL__ |
          | Sync status | ✅ Merged via upstream-sync |

          ---

          ## Upstream Release Notes (__UPSTREAM_TAG__)

          HEADER_EOF

          sed -i \
            -e "s|__NEW_TAG__|${NEW_TAG}|g" \
            -e "s|__UPSTREAM_TAG__|${UPSTREAM_TAG}|g" \
            -e "s|__UPSTREAM_URL__|https://github.com/${UPSTREAM_REPO}/releases/tag/${UPSTREAM_TAG}|g" \
            /tmp/release-body.md

          # Append upstream body OUTSIDE heredoc to safely pass through $, backticks, etc. (P3)
          printf '%s\n' "$UPSTREAM_BODY" >> /tmp/release-body.md

      - name: Inject release body or create release directly
        if: steps.gate.outputs.proceed == 'true'
        run: |
          NEW_TAG="${{ steps.compute_tag.outputs.new_tag }}"

          if [ "${{ steps.poll_release.outputs.created }}" = "true" ]; then
            # release.yml already created the release — overwrite auto-generated notes
            # Use release ID (not tag name) to avoid 'release not found' from gh release edit's by-tag lookup
            RELEASE_ID="${{ steps.poll_release.outputs.release_id }}"
            jq -n --rawfile body /tmp/release-body.md '{"body": $body}' > /tmp/release-patch.json
            gh api --method PATCH "repos/$GITHUB_REPOSITORY/releases/${RELEASE_ID}" \
              --input /tmp/release-patch.json
            echo "Release body updated via gh api PATCH (id=${RELEASE_ID})."
          else
            # Fallback: release.yml timed out; create release directly with full body
            gh release create "$NEW_TAG" \
              --repo "$GITHUB_REPOSITORY" \
              --title "GSD Copilot ${NEW_TAG}" \
              --notes-file /tmp/release-body.md
            echo "Release created directly (fallback path)."
          fi

      - name: Handle failure — create or update GitHub issue
        if: failure() && steps.preflight.outputs.skip != 'true'
        run: |
          UPSTREAM_TAG="${{ steps.detect_release.outputs.upstream_tag }}"
          NEW_TAG="${{ steps.compute_tag.outputs.new_tag }}"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          REPO_OWNER=$(gh api "repos/$GITHUB_REPOSITORY" --jq '.owner.login' 2>/dev/null || echo "")
          RECENT_LOG=$(git log --oneline -5 2>/dev/null || echo "(unavailable)")

          # Stable title — run number must NOT appear here or dedup search will never match a prior issue
          ISSUE_TITLE="[upstream-mirror] Release mirror failure"

          # Verbose diagnostic body written to file — never --body with inline multi-line string
          cat > /tmp/failure-detail.md << BODY_EOF
          ## upstream-mirror Failure — Run #${{ github.run_number }}

          | Field | Value |
          |---|---|
          | Workflow run | [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |
          | Timestamp | ${TIMESTAMP} |
          | Upstream tag checked | ${UPSTREAM_TAG:-"(not yet resolved)"} |
          | Fork tag at failure | ${NEW_TAG:-"(not yet computed)"} |

          ### Recent git log (last 5 commits)
          \`\`\`
          ${RECENT_LOG}
          \`\`\`

          ### Environment (secrets redacted)
          - GITHUB_REPOSITORY: \`$GITHUB_REPOSITORY\`
          - GITHUB_REF: \`$GITHUB_REF\`
          - EXPECTED_REPO: \`${{ env.EXPECTED_REPO }}\`
          BODY_EOF

          # Deduplication: comment on existing open issue rather than create a duplicate
          EXISTING=$(gh issue list \
            --repo "$GITHUB_REPOSITORY" \
            --search "is:issue is:open \"${ISSUE_TITLE}\" in:title" \
            --json number \
            --jq '.[0].number' 2>/dev/null || echo "")

          if [ -n "$EXISTING" ] && [ "$EXISTING" != "null" ]; then
            gh issue comment "$EXISTING" \
              --repo "$GITHUB_REPOSITORY" \
              --body-file /tmp/failure-detail.md
            echo "Commented on existing issue #${EXISTING}."
          else
            gh issue create \
              --repo "$GITHUB_REPOSITORY" \
              --title "${ISSUE_TITLE}" \
              --label "bug" \
              --label "upstream-mirror" \
              ${REPO_OWNER:+--assignee "$REPO_OWNER"} \
              --body-file /tmp/failure-detail.md
            echo "Created new issue."
          fi

